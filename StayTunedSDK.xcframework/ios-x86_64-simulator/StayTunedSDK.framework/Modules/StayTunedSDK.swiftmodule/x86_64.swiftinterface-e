// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.4.2 (swiftlang-1205.0.28.2 clang-1205.0.19.57)
// swift-module-flags: -target x86_64-apple-ios11.0-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name StayTunedSDK
import AVKit
import CoreData
import Foundation
import GoogleInteractiveMediaAds
import MediaPlayer
import MobileCoreServices
import Swift
import SystemConfiguration
import UIKit
public struct STContentViewConfiguration : StayTunedSDK.STUIInstantiableConfiguration {
  public let contentKey: Swift.String
  public init(contentKey: Swift.String)
}
public protocol STUIInjectionContentView : UIKit.UIViewController {
  init(_ configuration: StayTunedSDK.STContentViewConfiguration)
}
@propertyWrapper public class Observable<Value> {
  @available(*, deprecated, message: "Observation will be removed in 1.1.0. Please use delegate pattern.")
  public var projectedValue: StayTunedSDK.Observable<Value> {
    get
  }
  @available(*, deprecated, message: "Observation will be removed in 1.1.0. Please use delegate pattern.")
  public var wrappedValue: Value {
    get
    set
  }
  public init(wrappedValue: Value)
  @objc deinit
}
extension Observable {
  @discardableResult
  @available(*, deprecated, message: "Observation will be removed in 1.1.0. Please use delegate pattern.")
  public func observe(with closure: @escaping (Value) -> Swift.Void) -> StayTunedSDK.STObservable.Cancellable
}
public enum STObservable {
  @_hasMissingDesignatedInitializers final public class Cancellable {
    @objc deinit
    final public func cancel()
  }
}
public struct STContentLightOfflineItem {
  public let audioItem: StayTunedSDK.STContentLight
  public var state: StayTunedSDK.STOfflineState
}
@_hasMissingDesignatedInitializers final public class STLocalLists : StayTunedSDK.STFeature {
  public static func getInstance() throws -> StayTunedSDK.STLocalLists
  final public func getLists(completion: @escaping (Swift.Result<[StayTunedSDK.STListProtocol], Swift.Error>) -> Swift.Void)
  final public func create<Item>(name: Swift.String, type: StayTunedSDK.STListType, completion: @escaping (Swift.Result<StayTunedSDK.STList<Item>, Swift.Error>) -> Swift.Void)
  final public func createOrGet<Item>(name: Swift.String, type: StayTunedSDK.STListType, completion: @escaping (Swift.Result<StayTunedSDK.STList<Item>, Swift.Error>) -> Swift.Void)
  final public func getList<Item>(by id: Swift.Int, completion: @escaping (Swift.Result<StayTunedSDK.STList<Item>, Swift.Error>) -> Swift.Void)
  final public func update<Item>(_ list: StayTunedSDK.STList<Item>, completion: @escaping (Swift.Result<Swift.Void, Swift.Error>) -> Swift.Void)
  final public func delete(listId: Swift.Int, completion: @escaping (Swift.Result<Swift.Void, Swift.Error>) -> Swift.Void)
  final public func updateItems<Item>(listId: Swift.Int, items: [StayTunedSDK.STListItem<Item>], completion: @escaping (Swift.Result<[StayTunedSDK.STListItem<Item>], Swift.Error>) -> Swift.Void)
  final public func addItems<Item>(listId: Swift.Int, items: [StayTunedSDK.STListItem<Item>], completion: @escaping (Swift.Result<[StayTunedSDK.STListItem<Item>], Swift.Error>) -> Swift.Void)
  final public func deleteItems<Item>(listId: Swift.Int, items: [StayTunedSDK.STListItem<Item>], completion: @escaping (Swift.Result<Swift.Int?, Swift.Error>) -> Swift.Void)
  final public func syncItems<Item>(listId: Swift.Int, items: [StayTunedSDK.STListItem<Item>], completion: @escaping (Swift.Result<[StayTunedSDK.STListItem<Item>], Swift.Error>) -> Swift.Void)
  @objc deinit
}
public typealias STTrackList = StayTunedSDK.STList<StayTunedSDK.STTrack>
public typealias STContentList = StayTunedSDK.STList<StayTunedSDK.STContentLight>
public typealias STTrackListItem = StayTunedSDK.STListItem<StayTunedSDK.STTrack>
public typealias STContentListItem = StayTunedSDK.STListItem<StayTunedSDK.STContentLight>
public enum STError : Swift.Error {
  case notInitException
  case alreadyInitException
  case featureNotAvailable
  case missingRefreshTokenInKeychain
  case missingAnonymousCredentialsInKeychain
  case unknowned
  public static func == (a: StayTunedSDK.STError, b: StayTunedSDK.STError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol STPlayerObserver : AnyObject {
  func playerCurrentTrackDidChange(to track: StayTunedSDK.STTrack)
  func playerCurrentTrackAudioQualityDidChange(to value: StayTunedSDK.STAudioQuality)
  func playerCurrentContentDidChange(to content: StayTunedSDK.STContent)
  func playerStateDidChange(to value: StayTunedSDK.STPlayerState)
  func playerCurrentTimeDidChange(to value: Swift.Double)
  func playerWillSeek(from beginTime: Swift.Double?)
  func playerDidSeek(to endTime: Swift.Double)
  func playerRateDidChange(to value: Swift.Float)
  func playerTimerDidChange(to value: Foundation.TimeInterval?)
  func playerTrackDidEnd(_ track: StayTunedSDK.STTrack)
  func playerFailed(for track: StayTunedSDK.STTrack)
}
extension String : Swift.CodingKey {
  public var stringValue: Swift.String {
    get
  }
  public init?(stringValue: Swift.String)
  public var intValue: Swift.Int? {
    get
  }
  public init?(intValue: Swift.Int)
}
public protocol STObservableProtocol {
  associatedtype Observer
  func add(observer: Self.Observer)
  func remove(observer: Self.Observer)
}
public class STPlaylist {
  public var tracks: [StayTunedSDK.STTrack]
  public var hasNext: Swift.Bool {
    get
  }
  public var hasPrevious: Swift.Bool {
    get
  }
  public init(tracks: [StayTunedSDK.STTrack])
  convenience public init(content: StayTunedSDK.STContent)
  @discardableResult
  public func next() -> StayTunedSDK.STTrack?
  @discardableResult
  public func previous() -> StayTunedSDK.STTrack?
  @objc deinit
}
public struct STContentsConfiguration {
  public var cachingOptions: StayTunedSDK.STContentCachingOptions
  public init(cachingOptions: StayTunedSDK.STContentCachingOptions = .init())
}
public struct STContentCachingOptions {
  public var enabledContentCaching: Swift.Bool
  public var maxCachedContent: Swift.Int
  public init(enabledContentCaching: Swift.Bool = false, maxCachedContent: Swift.Int = 0)
}
public enum STPodcastDescriptionIdentityModels {
  public struct Style {
  }
  public struct ContentData {
  }
}
@_hasMissingDesignatedInitializers final public class STContents : StayTunedSDK.STFeature {
  public static func getInstance() throws -> StayTunedSDK.STContents
  @objc deinit
}
extension STContents {
  final public func setConfiguration(_ configuration: StayTunedSDK.STContentsConfiguration)
  final public func get(by key: Swift.String, completion: @escaping (Swift.Result<StayTunedSDK.STContent, Swift.Error>) -> Swift.Void)
  final public func getAll(completion: @escaping (Swift.Result<[StayTunedSDK.STContentLight], Swift.Error>) -> Swift.Void)
  final public func search(_ search: StayTunedSDK.STContentsSearch, completion: @escaping (Swift.Result<[StayTunedSDK.STContentLight], Swift.Error>) -> Swift.Void)
}
public enum STAudioQuality {
  case normal
  case hd
  public static func == (a: StayTunedSDK.STAudioQuality, b: StayTunedSDK.STAudioQuality) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public class STWeakRef {
  weak public var value: Swift.AnyObject? {
    get
  }
  public init(value: Swift.AnyObject?)
  @objc deinit
}
public struct STContent : Swift.Hashable {
  public static let EMPTY_PROPERTY: Swift.String
  public let key: Swift.String
  public let type: StayTunedSDK.STContentModelType?
  public let title: Swift.String
  public let ean: Swift.String?
  public let imgSrc: Swift.String?
  public let portraitImgSrc: Swift.String?
  public let landscapeImgSrc: Swift.String?
  public let narrator: Swift.String?
  public let author: Swift.String?
  public let authorBibliographicalNote: Swift.String?
  public let publishingHouse: Swift.String?
  public let imprintName: Swift.String?
  public let advertiser: Swift.String?
  public let language: Swift.String?
  public let descriptionText: Swift.String?
  public let mediaType: StayTunedSDK.STContentMediaType?
  public let diffusionMode: StayTunedSDK.STContentDiffusionMode?
  public let disponibilityStatus: StayTunedSDK.STContentDisponibilityStatus?
  public let complete: Swift.Bool?
  #warning("TODO: documentation")
  public let isExplicitContent: Swift.Bool?
  #warning("TODO: documentation, add usage example")
  public let categories: Swift.String?
  public let copyright: Swift.String?
  public let websiteUrl: Swift.String?
  public let rssFeedUrl: Swift.String?
  public let vastUrl: Swift.String?
  public let pdfUrl: Swift.String?
  public let publicationDate: Foundation.Date?
  public let overallDuration: Swift.Int?
  public let elementList: [StayTunedSDK.STTrack]?
  public let createdAt: Foundation.Date?
  public let updatedAt: Foundation.Date?
  public init(key: Swift.String, type: StayTunedSDK.STContentModelType? = nil, title: Swift.String, ean: Swift.String? = nil, imgSrc: Swift.String? = nil, portraitImgSrc: Swift.String? = nil, landscapeImgSrc: Swift.String? = nil, narrator: Swift.String? = nil, author: Swift.String? = nil, authorBibliographicalNote: Swift.String? = nil, publishingHouse: Swift.String? = nil, imprintName: Swift.String? = nil, advertiser: Swift.String? = nil, language: Swift.String? = nil, descriptionText: Swift.String? = nil, mediaType: StayTunedSDK.STContentMediaType? = nil, diffusionMode: StayTunedSDK.STContentDiffusionMode? = nil, disponibilityStatus: StayTunedSDK.STContentDisponibilityStatus? = nil, complete: Swift.Bool? = nil, isExplicitContent: Swift.Bool? = nil, categories: Swift.String? = nil, copyright: Swift.String? = nil, websiteUrl: Swift.String? = nil, rssFeedUrl: Swift.String? = nil, vastUrl: Swift.String? = nil, pdfUrl: Swift.String? = nil, publicationDate: Foundation.Date? = nil, overallDuration: Swift.Int? = nil, elementList: [StayTunedSDK.STTrack]? = nil, updatedAt: Foundation.Date? = nil, createdAt: Foundation.Date? = nil)
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension STContent {
  public var contentLight: StayTunedSDK.STContentLight {
    get
  }
}
public enum STContentModelType : Swift.String, Swift.Codable {
  case podcast
  case audiobook
  case livestream
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum STContentMediaType : Swift.String, Swift.Codable {
  case edito
  case brand
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum STContentDiffusionMode : Swift.String, Swift.Codable {
  case episodic
  case serial
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum STContentDisponibilityStatus : Swift.String, Swift.Codable {
  case forthcoming
  case available
  case stopped
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
extension STContent : Swift.Equatable {
  public static func == (lhs: StayTunedSDK.STContent, rhs: StayTunedSDK.STContent) -> Swift.Bool
}
public protocol STFeature {
  static func getInstance() throws -> Self
  static var shared: Self? { get }
}
extension STFeature {
  public static var shared: Self? {
    get
  }
}
public typealias STInternalEventsProtocols = StayTunedSDK.STInternalDownloadEventsProtocol & StayTunedSDK.STInternalErrorEventsProtocol & StayTunedSDK.STInternalPlayerEventsProtocol
public class STInternalEvents {
  public init(with manager: StayTunedSDK.STInternalEventsProtocols? = nil)
  @objc deinit
}
open class STInternalEventsDefaultDelegate : StayTunedSDK.STInternalEventsProtocols {
  public init()
  open func downlaodShouldStart(for track: StayTunedSDK.STTrack) -> Swift.Bool
  open func downloadWillStart(for track: StayTunedSDK.STTrack)
  open func downloadDidFinish(for track: StayTunedSDK.STTrack)
  open func playerWillStart(for track: StayTunedSDK.STTrack)
  open func playerDidFinish(for track: StayTunedSDK.STTrack)
  open func didFailedToloadItem(for itemUrl: Swift.String, error: Swift.String)
  open func eventsErrorDidOccur(_ error: Swift.Error)
  @objc deinit
}
#warning("TODO: STTrackingNavigationAdapter")
public protocol STInternalErrorEventsProtocol : AnyObject {
  func eventsErrorDidOccur(_ error: Swift.Error)
}
@_hasMissingDesignatedInitializers final public class STExpand : StayTunedSDK.STFeature {
  public static func getInstance() throws -> StayTunedSDK.STExpand
  final public func setConfiguration(_ configuration: StayTunedSDK.STExpandConfiguration)
  final public func present(from presenter: UIKit.UIViewController)
  final public func dismiss(completion: (() -> Swift.Void)?)
  @objc deinit
}
public struct STNowPlayingInfoCenterModel {
}
public struct STUIOptions {
  public enum UserInterfaceStyle {
    case app
    case light
    case dark
    public static func == (a: StayTunedSDK.STUIOptions.UserInterfaceStyle, b: StayTunedSDK.STUIOptions.UserInterfaceStyle) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let brandColor: UIKit.UIColor
  public let interfaceStyle: StayTunedSDK.STUIOptions.UserInterfaceStyle
  public init(brandColor: UIKit.UIColor = UIColor.systemPink, interfaceStyle: StayTunedSDK.STUIOptions.UserInterfaceStyle = .app)
}
@_hasMissingDesignatedInitializers final public class STWishes : StayTunedSDK.STFeature {
  public static func getInstance() throws -> StayTunedSDK.STWishes
  final public func get(completion: ((Swift.Result<(contents: [StayTunedSDK.STContentWish], tracks: [StayTunedSDK.STTrackWish]), Swift.Error>) -> Swift.Void)?)
  final public func add<Item>(wish: StayTunedSDK.STWish<Item>, completion: ((Swift.Result<Swift.Void, Swift.Error>) -> Swift.Void)?)
  final public func delete<Item>(wish: StayTunedSDK.STWish<Item>, completion: ((Swift.Result<Swift.Void, Swift.Error>) -> Swift.Void)?)
  final public func reset()
  @objc deinit
}
extension STWishes : StayTunedSDK.STObservableProtocol {
  final public func add(observer: StayTunedSDK.STWishesObserver)
  final public func remove(observer: StayTunedSDK.STWishesObserver)
  public typealias Observer = StayTunedSDK.STWishesObserver
}
public protocol STWishesObserver : AnyObject {
  func wishesDidGet(_ contents: [StayTunedSDK.STContentWish], _ tracks: [StayTunedSDK.STTrackWish])
  func wishesDidAdd(content: StayTunedSDK.STContentWish)
  func wishesDidRemove(content: StayTunedSDK.STContentWish)
  func wishesDidAdd(track: StayTunedSDK.STTrackWish)
  func wishesDidRemove(track: StayTunedSDK.STTrackWish)
}
public enum STListType {
  case bookmark, playlist, favorite, queue, custom(Swift.String)
}
extension STListType : Swift.Equatable {
  public static func == (lhs: StayTunedSDK.STListType, rhs: StayTunedSDK.STListType) -> Swift.Bool
}
public enum STListLinkedContentType : Swift.String {
  case content
  case track
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public protocol STListProtocol {
  var id: Swift.Int? { get }
  var name: Swift.String? { get set }
  var type: StayTunedSDK.STListType? { get set }
  var imgSrc: Swift.String? { get set }
  var linkedContentType: StayTunedSDK.STListLinkedContentType? { get }
  var numberOfItems: Swift.Int? { get }
  var createdAt: Foundation.Date? { get }
  var updatedAt: Foundation.Date? { get }
  func delete(completion: @escaping (Swift.Result<Swift.Void, Swift.Error>) -> Swift.Void)
  func getItems(completion: @escaping (Swift.Result<Swift.Void, Swift.Error>) -> Swift.Void)
  func update(completion: @escaping (Swift.Result<Swift.Void, Swift.Error>) -> Swift.Void)
  func syncItems(completion: @escaping (Swift.Result<Swift.Void, Swift.Error>) -> Swift.Void)
}
public struct STList<Item> : StayTunedSDK.STListProtocol {
  public var isLocal: Swift.Bool {
    get
  }
  public var id: Swift.Int? {
    get
  }
  public var name: Swift.String? {
    get
    set
  }
  public var type: StayTunedSDK.STListType? {
    get
    set
  }
  public var imgSrc: Swift.String? {
    get
    set
  }
  public var linkedContentType: StayTunedSDK.STListLinkedContentType? {
    get
  }
  public var numberOfItems: Swift.Int? {
    get
  }
  public var items: [StayTunedSDK.STListItem<Item>] {
    get
    set
  }
  public var createdAt: Foundation.Date? {
    get
  }
  public var updatedAt: Foundation.Date? {
    get
  }
  public init(name: Swift.String, type: StayTunedSDK.STListType)
}
extension STList {
  public func delete(completion: @escaping (Swift.Result<Swift.Void, Swift.Error>) -> Swift.Void)
  public func getItems(completion: @escaping (Swift.Result<Swift.Void, Swift.Error>) -> Swift.Void)
  public func update(completion: @escaping (Swift.Result<Swift.Void, Swift.Error>) -> Swift.Void)
  public func updateItems(_ items: [StayTunedSDK.STListItem<Item>], completion: @escaping (Swift.Result<Swift.Void, Swift.Error>) -> Swift.Void)
  public func updateItem(_ item: StayTunedSDK.STListItem<Item>, completion: @escaping (Swift.Result<Swift.Void, Swift.Error>) -> Swift.Void)
  public func addItems(_ items: [StayTunedSDK.STListItem<Item>], completion: @escaping (Swift.Result<Swift.Void, Swift.Error>) -> Swift.Void)
  public func addItem(_ item: StayTunedSDK.STListItem<Item>, completion: @escaping (Swift.Result<Swift.Void, Swift.Error>) -> Swift.Void)
  public func deleteItems(_ items: [StayTunedSDK.STListItem<Item>], completion: @escaping (Swift.Result<Swift.Void, Swift.Error>) -> Swift.Void)
  public func deleteItem(_ item: StayTunedSDK.STListItem<Item>, completion: @escaping (Swift.Result<Swift.Void, Swift.Error>) -> Swift.Void)
  public func syncItems(completion: @escaping (Swift.Result<Swift.Void, Swift.Error>) -> Swift.Void)
}
extension STList : StayTunedSDK.STObservableProtocol {
  public func add(observer: StayTunedSDK.STListObserver)
  public func remove(observer: StayTunedSDK.STListObserver)
  public typealias Observer = StayTunedSDK.STListObserver
}
public protocol STListObserver : AnyObject {
  func itemsDidChange<Item>(to value: [StayTunedSDK.STListItem<Item>])
}
public enum STAPIDownloadError : Swift.Error {
  case responseDataMissing
  case responseFailed
  case requestMissing
  case requestMissingPath
  case requestMissingURL
  public static func == (a: StayTunedSDK.STAPIDownloadError, b: StayTunedSDK.STAPIDownloadError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers final public class STTracks : StayTunedSDK.STFeature {
  public static func getInstance() throws -> StayTunedSDK.STTracks
  @objc deinit
}
extension STTracks {
  final public func search(_ search: StayTunedSDK.STTracksSearch, completion: @escaping (Swift.Result<[StayTunedSDK.STTrack], Swift.Error>) -> Swift.Void)
}
public struct STFloatingChipConfiguration {
  public enum Size : CoreGraphics.CGFloat {
    case small
    case medium
    case large
    public init?(rawValue: CoreGraphics.CGFloat)
    public typealias RawValue = CoreGraphics.CGFloat
    public var rawValue: CoreGraphics.CGFloat {
      get
    }
  }
  public enum Position {
    case bottomRight(horizontalMargin: CoreGraphics.CGFloat, verticalMargin: CoreGraphics.CGFloat)
    case bottomLeft(horizontalMargin: CoreGraphics.CGFloat, verticalMargin: CoreGraphics.CGFloat)
  }
  public let size: StayTunedSDK.STFloatingChipConfiguration.Size
  public let position: StayTunedSDK.STFloatingChipConfiguration.Position
  public let animate: Swift.Bool
  public init(size: StayTunedSDK.STFloatingChipConfiguration.Size = .medium, position: StayTunedSDK.STFloatingChipConfiguration.Position = .bottomRight(horizontalMargin: 10, verticalMargin: 10), animate: Swift.Bool = true)
}
@_hasMissingDesignatedInitializers final public class STFloatingChip : StayTunedSDK.STFeature {
  public static func getInstance() throws -> StayTunedSDK.STFloatingChip
  @discardableResult
  final public func display(in viewController: UIKit.UIViewController, with configuration: StayTunedSDK.STFloatingChipConfiguration = .init()) -> UIKit.UIView
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class STSections : StayTunedSDK.STFeature {
  public static func getInstance() throws -> StayTunedSDK.STSections
  @objc deinit
}
extension STSections {
  final public func getSections(completion: @escaping (Swift.Result<[StayTunedSDK.STSection], Swift.Error>) -> Swift.Void)
  final public func getSection(by id: Swift.Int, completion: @escaping (Swift.Result<StayTunedSDK.STSection, Swift.Error>) -> Swift.Void)
}
@_hasMissingDesignatedInitializers final public class STTracking : StayTunedSDK.STFeature {
  public static func getInstance() throws -> StayTunedSDK.STTracking
  @objc deinit
}
extension STTracking {
  final public func inject(adapters: [StayTunedSDK.STTrackingAdapter])
}
@_hasMissingDesignatedInitializers final public class STCatalog : StayTunedSDK.STFeature {
  public static func getInstance() throws -> StayTunedSDK.STCatalog
  final public func get(completion: ((Swift.Result<(contents: [StayTunedSDK.STContentCatalogItem], tracks: [StayTunedSDK.STTrackCatalogItem]), Swift.Error>) -> Swift.Void)?)
  @objc deinit
}
public protocol STCatalogItemProtocol {
  var key: Swift.String? { get }
  var paymentType: Swift.String? { get }
  var amount: Swift.Float? { get }
  var taxPercent: Swift.Float? { get }
  var currency: Swift.String? { get }
  var countries: [Swift.String]? { get }
  var beginDate: Foundation.Date? { get }
  var endDate: Foundation.Date? { get }
  var createdAt: Foundation.Date? { get }
  var updatedAt: Foundation.Date? { get }
}
public struct STCatalogItem<Item> {
  public let key: Swift.String?
  public let paymentType: Swift.String?
  public let amount: Swift.Float?
  public let taxPercent: Swift.Float?
  public let currency: Swift.String?
  public let countries: [Swift.String]?
  public let beginDate: Foundation.Date?
  public let endDate: Foundation.Date?
  public let item: Item?
  public let createdAt: Foundation.Date?
  public let updatedAt: Foundation.Date?
}
extension STCatalogItem : StayTunedSDK.STCatalogItemProtocol {
}
extension STCatalogItem : Swift.Equatable where Item : Swift.Equatable {
  public static func == (lhs: StayTunedSDK.STCatalogItem<Item>, rhs: StayTunedSDK.STCatalogItem<Item>) -> Swift.Bool
}
public typealias STContentCatalogItem = StayTunedSDK.STCatalogItem<StayTunedSDK.STContentLight>
public typealias STTrackCatalogItem = StayTunedSDK.STCatalogItem<StayTunedSDK.STTrack>
public struct STTrackHistoryItem {
  public let audioItem: StayTunedSDK.STTrack
  public var time: Swift.Double
  public var createdAt: Foundation.Date?
  public var updatedAt: Foundation.Date
}
extension STTrackHistoryItem {
  public static func updateOrder(lhs: StayTunedSDK.STTrackHistoryItem, rhs: StayTunedSDK.STTrackHistoryItem) -> Swift.Bool
}
extension STTrackHistoryItem : Swift.Equatable {
  public static func == (a: StayTunedSDK.STTrackHistoryItem, b: StayTunedSDK.STTrackHistoryItem) -> Swift.Bool
}
public struct STContentHistoryItem {
  public let audioItem: StayTunedSDK.STContent
  public var time: Swift.Double
  public var createdAt: Foundation.Date?
  public var updatedAt: Foundation.Date
}
extension STContentHistoryItem {
  public static func updateOrder(lhs: StayTunedSDK.STContentHistoryItem, rhs: StayTunedSDK.STContentHistoryItem) -> Swift.Bool
}
public struct STOptions {
  public let uiOptions: StayTunedSDK.STUIOptions
  public let trackPlayUrlExtra: Swift.String
  public let trackDownloadUrlExtra: Swift.String
  public let requestHeaders: [Swift.String : Swift.String]
  public init(uiOptions: StayTunedSDK.STUIOptions = STUIOptions(), trackPlayUrlExtra: Swift.String = "", trackDownloadUrlExtra: Swift.String = "", requestHeaders: [Swift.String : Swift.String] = [:])
}
@_hasMissingDesignatedInitializers final public class STHooks : StayTunedSDK.STFeature {
  public static func getInstance() throws -> StayTunedSDK.STHooks
  final public var getContentByKey: ((Swift.String, @escaping (StayTunedSDK.STContent?) -> Swift.Void) -> Swift.Void)? {
    get
    set
  }
  @objc deinit
}
public protocol STSplitTestingGroupAssignment {
  func groupKey(for testKey: Swift.String) -> Swift.String?
}
@_hasMissingDesignatedInitializers final public class STWallets : StayTunedSDK.STFeature {
  public static func getInstance() throws -> StayTunedSDK.STWallets
  final public var wallets: [StayTunedSDK.STWallet] {
    get
  }
  final public func getWallets(completion: ((Swift.Result<Swift.Void, Swift.Error>) -> Swift.Void)?)
  @objc deinit
}
extension STWallets : StayTunedSDK.STObservableProtocol {
  final public func add(observer: StayTunedSDK.STWalletsObserver)
  final public func remove(observer: StayTunedSDK.STWalletsObserver)
  public typealias Observer = StayTunedSDK.STWalletsObserver
}
public protocol STWalletsObserver : AnyObject {
  func walletsDidChange(to value: [StayTunedSDK.STWallet])
}
public enum STContentTypeEnum : Swift.String, Swift.Codable {
  case podcast
  case livestream
  case audiobook
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public protocol STWishProtocol {
  var id: Swift.Int? { get }
  var key: Swift.String { get }
  var createdAt: Foundation.Date? { get }
  var updatedAt: Foundation.Date? { get }
}
public struct STWish<Item> {
  public var id: Swift.Int?
  public var key: Swift.String
  public var item: Item?
  public var createdAt: Foundation.Date?
  public var updatedAt: Foundation.Date?
}
extension STWish : StayTunedSDK.STWishProtocol {
}
extension STWish : Swift.Equatable where Item : Swift.Equatable {
  public static func == (lhs: StayTunedSDK.STWish<Item>, rhs: StayTunedSDK.STWish<Item>) -> Swift.Bool
}
extension STWish {
  public static func updateOrder(lhs: StayTunedSDK.STWish<Item>, rhs: StayTunedSDK.STWish<Item>) -> Swift.Bool
}
extension STWish where Item == StayTunedSDK.STTrack {
  public init(track: StayTunedSDK.STTrack)
}
extension STWish where Item == StayTunedSDK.STContentLight {
  public init(content: StayTunedSDK.STContentLight)
}
public typealias STTrackWish = StayTunedSDK.STWish<StayTunedSDK.STTrack>
public typealias STContentWish = StayTunedSDK.STWish<StayTunedSDK.STContentLight>
@_hasMissingDesignatedInitializers final public class STOffline : StayTunedSDK.STFeature {
  public static func getInstance() throws -> StayTunedSDK.STOffline
  final public var contents: [StayTunedSDK.STContentLightOfflineItem] {
    get
  }
  final public func remove(content: StayTunedSDK.STContent) throws
  final public func add(content: StayTunedSDK.STContent, completion: ((Swift.Result<Swift.Void, Swift.Error>) -> Swift.Void)? = nil)
  final public func cancel(content: StayTunedSDK.STContent) throws
  final public var tracks: [StayTunedSDK.STTrackOfflineItem] {
    get
  }
  final public func add(track: StayTunedSDK.STTrack, completion: ((Swift.Result<Swift.Void, Swift.Error>) -> Swift.Void)? = nil)
  final public func remove(track: StayTunedSDK.STTrack) throws
  final public func cancel(track: StayTunedSDK.STTrack) throws
  final public func application(_ application: UIKit.UIApplication, handleEventsForBackgroundURLSession identifier: Swift.String, completionHandler: @escaping () -> Swift.Void)
  @objc deinit
}
extension STOffline : StayTunedSDK.STObservableProtocol {
  final public func add(observer: StayTunedSDK.STOfflineObserver)
  final public func remove(observer: StayTunedSDK.STOfflineObserver)
  public typealias Observer = StayTunedSDK.STOfflineObserver
}
public protocol STOfflineObserver : AnyObject {
  func offlineContentItemDidChange(_ item: StayTunedSDK.STContentLightOfflineItem)
  func offlineTrackItemsDidChange(_ items: [StayTunedSDK.STTrackOfflineItem])
}
public enum STOfflineError : Swift.Error {
  case lowMemory
  public static func == (a: StayTunedSDK.STOfflineError, b: StayTunedSDK.STOfflineError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers final public class STTransactions : StayTunedSDK.STFeature {
  public static func getInstance() throws -> StayTunedSDK.STTransactions
  final public func get(completion: ((Swift.Result<(contents: [StayTunedSDK.STContentTransaction], tracks: [StayTunedSDK.STTrackTransaction]), Swift.Error>) -> Swift.Void)?)
  final public func fetch(completion: ((Swift.Result<(contents: [StayTunedSDK.STContentTransaction], tracks: [StayTunedSDK.STTrackTransaction]), Swift.Error>) -> Swift.Void)?)
  final public func create<Item>(transaction: StayTunedSDK.STTransaction<Item>, completion: ((Swift.Result<Swift.Void, Swift.Error>) -> Swift.Void)?)
  final public func reset()
  @objc deinit
}
extension STTransactions : StayTunedSDK.STObservableProtocol {
  final public func add(observer: StayTunedSDK.STTransactionsObserver)
  final public func remove(observer: StayTunedSDK.STTransactionsObserver)
  public typealias Observer = StayTunedSDK.STTransactionsObserver
}
public protocol STTransactionsObserver : AnyObject {
  func transactionsDidGet(_ contents: [StayTunedSDK.STContentTransaction], _ tracks: [StayTunedSDK.STTrackTransaction])
  func transactionsDidAdd(content: StayTunedSDK.STContentTransaction)
  func transactionsDidAdd(track: StayTunedSDK.STTrackTransaction)
}
public struct STTracksSearch {
  public init(title: Swift.String)
}
@objc open class STPlayerSceneViewController : UIKit.UITableViewController, StayTunedSDK.STUIInjectionPlayerView {
  required public init(_ configuration: StayTunedSDK.STPlayerViewConfiguration)
  @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc override dynamic public init(style: UIKit.UITableView.Style)
  @objc override dynamic open func viewDidLoad()
  @objc override dynamic open func viewWillAppear(_ animated: Swift.Bool)
  @objc override dynamic open func viewDidAppear(_ animated: Swift.Bool)
  @objc override dynamic open func traitCollectionDidChange(_ previousTraitCollection: UIKit.UITraitCollection?)
  @objc override dynamic open func numberOfSections(in tableView: UIKit.UITableView) -> Swift.Int
  @objc override dynamic open func tableView(_ tableView: UIKit.UITableView, numberOfRowsInSection section: Swift.Int) -> Swift.Int
  @objc override dynamic open func tableView(_ tableView: UIKit.UITableView, cellForRowAt indexPath: Foundation.IndexPath) -> UIKit.UITableViewCell
  @objc override dynamic open func tableView(_ tableView: UIKit.UITableView, didSelectRowAt indexPath: Foundation.IndexPath)
  @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @objc deinit
}
public enum STAPIDecodableError : Swift.Error {
  case emptyDataResponse
  case nilHTTPResponse
  case unsuccessfulHTTPStatusCode
  case jsonDecoding(Swift.DecodingError)
  case generalError(Swift.Error)
}
public struct STPlayerViewConfiguration : StayTunedSDK.STUIInstantiableConfiguration {
}
public protocol STUIInjectionPlayerView : UIKit.UIViewController {
  init(_ configuration: StayTunedSDK.STPlayerViewConfiguration)
}
public protocol STInternalDownloadEventsProtocol : AnyObject {
  func downlaodShouldStart(for track: StayTunedSDK.STTrack) -> Swift.Bool
  func downloadWillStart(for track: StayTunedSDK.STTrack)
  func downloadDidFinish(for track: StayTunedSDK.STTrack)
}
@_hasMissingDesignatedInitializers final public class STUsers : StayTunedSDK.STFeature {
  public static func getInstance() throws -> StayTunedSDK.STUsers
  final public func get(completion: ((Swift.Result<StayTunedSDK.STUser, Swift.Error>) -> Swift.Void)?)
  final public func update(_ user: StayTunedSDK.STUser, completion: ((Swift.Result<StayTunedSDK.STUser, Swift.Error>) -> Swift.Void)?)
  @objc deinit
}
final public class StayTunedSDK {
  @discardableResult
  public init(appId: Swift.String, authToken: Swift.String, options: StayTunedSDK.STOptions = STOptions()) throws
  public static func getInstance() throws -> StayTunedSDK.StayTunedSDK
  final public func reset()
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class STHistory : StayTunedSDK.STFeature {
  public static func getInstance() throws -> StayTunedSDK.STHistory
  final public var contents: [StayTunedSDK.STContentHistoryItem] {
    get
  }
  final public var tracks: [StayTunedSDK.STTrackHistoryItem] {
    get
  }
  final public func sync(completion: @escaping (Swift.Result<Swift.Void, Swift.Error>) -> Swift.Void)
  @objc deinit
}
public protocol STHistoryObserver : AnyObject {
  func historyDidSync()
  func historyContentItemDidChange(_ item: StayTunedSDK.STContentHistoryItem)
  func historyTrackItemDidChange(_ item: StayTunedSDK.STTrackHistoryItem)
}
extension STHistory : StayTunedSDK.STObservableProtocol {
  final public func add(observer: StayTunedSDK.STHistoryObserver)
  final public func remove(observer: StayTunedSDK.STHistoryObserver)
  public typealias Observer = StayTunedSDK.STHistoryObserver
}
@objc open class STContentViewController : UIKit.UITableViewController, StayTunedSDK.STUIInjectionContentView {
  required public init(_ configuration: StayTunedSDK.STContentViewConfiguration)
  @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc override dynamic open func viewDidLoad()
  @objc override dynamic open func viewWillAppear(_ animated: Swift.Bool)
  @objc override dynamic public init(style: UIKit.UITableView.Style)
  @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @objc deinit
}
extension STContentViewController {
  @objc override dynamic open func tableView(_ tableView: UIKit.UITableView, cellForRowAt indexPath: Foundation.IndexPath) -> UIKit.UITableViewCell
  @objc override dynamic open func tableView(_ tableView: UIKit.UITableView, viewForHeaderInSection section: Swift.Int) -> UIKit.UIView?
  @objc override dynamic open func tableView(_ tableView: UIKit.UITableView, didSelectRowAt indexPath: Foundation.IndexPath)
  @objc override dynamic open func tableView(_ tableView: UIKit.UITableView, heightForHeaderInSection section: Swift.Int) -> CoreGraphics.CGFloat
  @objc override dynamic open func numberOfSections(in tableView: UIKit.UITableView) -> Swift.Int
  @objc override dynamic open func tableView(_ tableView: UIKit.UITableView, numberOfRowsInSection section: Swift.Int) -> Swift.Int
}
public protocol STTrackingAdapter {
}
public protocol STTrackingPlayerAdapter : StayTunedSDK.STTrackingAdapter {
  func trackDidStart(track: StayTunedSDK.STTrack)
  func positionDidChange(position: Swift.Double)
  func durationDidChange(duration: Foundation.TimeInterval)
  func percentilePlayed(percentile: Swift.Int)
}
@_hasMissingDesignatedInitializers final public class STMiniPlayer : StayTunedSDK.STFeature {
  public static func getInstance() throws -> StayTunedSDK.STMiniPlayer
  final public var isDisplayed: Swift.Bool {
    get
  }
  final public func set(in viewController: UIKit.UIViewController)
  @objc deinit
}
public struct STAdsConfiguration {
  public var getVastUrl: (StayTunedSDK.STContent, StayTunedSDK.STTrack, @escaping (Swift.String?) -> Swift.Void) -> Swift.Void
  public init(getVastUrl: @escaping ((StayTunedSDK.STContent, StayTunedSDK.STTrack, @escaping (Swift.String?) -> Swift.Void) -> Swift.Void) = { content, _, completion  in
        completion(content.vastUrl)
    })
}
public protocol STUIFeatureInterface {
  func launchUI()
}
@_hasMissingDesignatedInitializers final public class STLists : StayTunedSDK.STFeature {
  public static func getInstance() throws -> StayTunedSDK.STLists
  final public func getLists(completion: @escaping (Swift.Result<[StayTunedSDK.STListProtocol], Swift.Error>) -> Swift.Void)
  final public func create<Item>(name: Swift.String, type: StayTunedSDK.STListType, completion: @escaping (Swift.Result<StayTunedSDK.STList<Item>, Swift.Error>) -> Swift.Void)
  final public func getOrCreate<Item>(name: Swift.String, type: StayTunedSDK.STListType, completion: @escaping (Swift.Result<StayTunedSDK.STList<Item>, Swift.Error>) -> Swift.Void)
  final public func getList<Item>(by id: Swift.Int, completion: @escaping (Swift.Result<StayTunedSDK.STList<Item>, Swift.Error>) -> Swift.Void)
  final public func update<Item>(_ list: StayTunedSDK.STList<Item>, completion: @escaping (Swift.Result<Swift.Void, Swift.Error>) -> Swift.Void)
  final public func delete(listId: Swift.Int, completion: @escaping (Swift.Result<Swift.Void, Swift.Error>) -> Swift.Void)
  final public func updateItems<Item>(listId: Swift.Int, items: [StayTunedSDK.STListItem<Item>], completion: @escaping (Swift.Result<[StayTunedSDK.STListItem<Item>], Swift.Error>) -> Swift.Void)
  final public func addItems<Item>(listId: Swift.Int, items: [StayTunedSDK.STListItem<Item>], completion: @escaping (Swift.Result<[StayTunedSDK.STListItem<Item>], Swift.Error>) -> Swift.Void)
  final public func deleteItems<Item>(listId: Swift.Int, items: [StayTunedSDK.STListItem<Item>], completion: @escaping (Swift.Result<Swift.Int?, Swift.Error>) -> Swift.Void)
  final public func syncItems<Item>(listId: Swift.Int, items: [StayTunedSDK.STListItem<Item>], completion: @escaping (Swift.Result<[StayTunedSDK.STListItem<Item>], Swift.Error>) -> Swift.Void)
  @objc deinit
}
public struct STContentsSearch {
  public init(title: Swift.String? = nil, author: Swift.String? = nil, narrator: Swift.String? = nil)
}
public enum STPlayerState : Swift.CaseIterable {
  case playing
  case paused
  case loading
  case playingAds
  case pauseAds
  public static func == (a: StayTunedSDK.STPlayerState, b: StayTunedSDK.STPlayerState) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [StayTunedSDK.STPlayerState]
  public static var allCases: [StayTunedSDK.STPlayerState] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
public struct STPlayerConfiguration {
  public var isContentCellVisible: Swift.Bool
  public var onContentCellClick: ((UIKit.UINavigationController) -> Swift.Void)?
  public var preferredAudioQuality: StayTunedSDK.STAudioQuality
  public var shouldResumeTrackFromHistory: ((StayTunedSDK.STTrack, StayTunedSDK.STTrackHistoryItem, ((Swift.Bool) -> Swift.Void)) -> Swift.Void)?
  public init(isContentCellVisible: Swift.Bool = false, onContentCellClick: ((UIKit.UINavigationController) -> Swift.Void)? = nil, preferredAudioQuality: StayTunedSDK.STAudioQuality = .normal, shouldResumeTrackFromHistory: ((StayTunedSDK.STTrack, StayTunedSDK.STTrackHistoryItem, ((Swift.Bool) -> Swift.Void)) -> Swift.Void)? = nil)
}
public struct STTrack {
  public let key: Swift.String
  public let contentKey: Swift.String
  public let contentTitle: Swift.String?
  public let type: StayTunedSDK.STTrackModelType?
  public let title: Swift.String
  public let subtitle: Swift.String?
  public let episode: Swift.Int?
  public let season: Swift.Int?
  public let slug: Swift.String?
  public let elementNumber: Swift.Int?
  public let chapter: Swift.Int?
  public let chapterPart: Swift.Int?
  public let websiteUrl: Swift.String?
  public let typeOfElement: StayTunedSDK.STTrackTypeOfElement?
  public let publicationDate: Foundation.Date?
  public let highlighted: Swift.Bool?
  public let descriptionText: Swift.String?
  public var imgSrc: Swift.String?
  public let audioSrc: Swift.String?
  public let audioSrcWeight: Swift.Int?
  public let hdAudioSrc: Swift.String?
  public let hdAudioSrcWeight: Swift.Int?
  public let audioDuration: Swift.Int?
  public let createdAt: Foundation.Date?
  public let updatedAt: Foundation.Date?
  public init(key: Swift.String, contentKey: Swift.String, contentTitle: Swift.String?, type: StayTunedSDK.STTrackModelType?, title: Swift.String, subtitle: Swift.String?, episode: Swift.Int?, season: Swift.Int?, slug: Swift.String?, elementNumber: Swift.Int?, chapter: Swift.Int?, chapterPart: Swift.Int?, websiteUrl: Swift.String?, typeOfElement: StayTunedSDK.STTrackTypeOfElement?, publicationDate: Foundation.Date?, highlighted: Swift.Bool?, descriptionText: Swift.String?, imgSrc: Swift.String?, audioSrc: Swift.String?, audioSrcWeight: Swift.Int?, hdAudioSrc: Swift.String?, hdAudioSrcWeight: Swift.Int?, audioDuration: Swift.Int?, createdAt: Foundation.Date?, updatedAt: Foundation.Date?)
}
public enum STTrackModelType : Swift.String, Swift.Codable {
  case track
  case livetrack
  case chapter
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum STTrackTypeOfElement : Swift.String, Swift.Codable {
  case full
  case trailer
  case bonus
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
extension STTrack : Swift.Equatable {
  public static func == (lhs: StayTunedSDK.STTrack, rhs: StayTunedSDK.STTrack) -> Swift.Bool
}
extension STTrack : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension STTrack : Swift.Encodable {
  public func encode(to encoder: Swift.Encoder) throws
}
public enum STAPIResponseError : Swift.Error {
  case error(Swift.Int, Foundation.Data?, Swift.Error)
}
public enum STOfflineState : Swift.Equatable, Swift.Codable {
  case notDownloaded
  case queued
  case downloading(Swift.Float?)
  case downloaded
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
  public static func == (a: StayTunedSDK.STOfflineState, b: StayTunedSDK.STOfflineState) -> Swift.Bool
}
public struct STAVPlayerSource {
  public let url: Foundation.URL
  public var audioQuality: StayTunedSDK.STAudioQuality {
    get
  }
  public init(track: StayTunedSDK.STTrack, preferredQuality: StayTunedSDK.STAudioQuality, appendURL queryItems: Swift.String = "") throws
}
public struct STWallet {
  public let paymentType: Swift.String?
  public let amount: Swift.Float?
  public let currency: Swift.String?
  public let lastSupplyAmount: Swift.Float?
  public let lastSupplyDate: Foundation.Date?
  public let createdAt: Foundation.Date?
  public let updatedAt: Foundation.Date?
}
@_hasMissingDesignatedInitializers final public class STPlayer : StayTunedSDK.STFeature {
  public static func getInstance() throws -> StayTunedSDK.STPlayer
  final public var currentList: StayTunedSDK.STPlaylist? {
    get
  }
  final public var currentTrack: StayTunedSDK.STTrack? {
    get
  }
  final public var currentContent: StayTunedSDK.STContent? {
    get
  }
  final public var currentTrackAudioQuality: StayTunedSDK.STAudioQuality? {
    get
  }
  final public var currentTime: Swift.Double? {
    get
  }
  final public var currentState: StayTunedSDK.STPlayerState {
    get
  }
  final public var rate: Swift.Float {
    get
  }
  final public var timerRemainingDuration: Foundation.TimeInterval? {
    get
  }
  final public func setConfiguration(_ configuration: StayTunedSDK.STPlayerConfiguration)
  final public func getConfiguration() -> StayTunedSDK.STPlayerConfiguration
  final public func setPreferredAudioQuality(_ preferredAudioQuality: StayTunedSDK.STAudioQuality)
  final public func play(playlist: StayTunedSDK.STPlaylist, at index: Swift.Int)
  final public func stop()
  final public func next()
  final public func prev()
  final public func seekTo(time: Swift.Double)
  final public func fastForward()
  final public func rewind()
  final public func setStopTimer(time: Swift.Double)
  final public func setStopAtEndOfTrack()
  final public func removeStopTimer()
  final public func getAudioDuration() -> Swift.Double?
  final public func getAudioCurrentTime() -> Swift.Double?
  final public func isPlaying() -> Swift.Bool
  final public func isPaused() -> Swift.Bool
  final public func isLoading() -> Swift.Bool
  final public func resume()
  @objc deinit
}
extension STPlayer {
  final public func add(observer: StayTunedSDK.STPlayerObserver)
  final public func remove(observer: StayTunedSDK.STPlayerObserver)
}
public struct STUser {
  public var key: Swift.String?
  public var email: Swift.String?
  public var firstName: Swift.String?
  public var lastName: Swift.String?
  public var dateOfBirth: Foundation.Date?
  public var emailSubscription: Swift.Bool?
  public var createdAt: Foundation.Date?
  public var updatedAt: Foundation.Date?
}
public protocol STTransactionProtocol {
  var key: Swift.String? { get }
  var paymentType: Swift.String? { get }
  var amount: Swift.Float? { get }
  var taxPercent: Swift.Float? { get }
  var currency: Swift.String? { get }
  var createdAt: Foundation.Date? { get }
  var updatedAt: Foundation.Date? { get }
}
public struct STTransaction<Item> {
  public let key: Swift.String?
  public let paymentType: Swift.String?
  public let amount: Swift.Float?
  public let taxPercent: Swift.Float?
  public let currency: Swift.String?
  public let item: Item?
  public let createdAt: Foundation.Date?
  public let updatedAt: Foundation.Date?
}
extension STTransaction : StayTunedSDK.STTransactionProtocol {
}
extension STTransaction : Swift.Equatable where Item : Swift.Equatable {
  public static func == (lhs: StayTunedSDK.STTransaction<Item>, rhs: StayTunedSDK.STTransaction<Item>) -> Swift.Bool
}
extension STTransaction {
  public static func updateOrder(lhs: StayTunedSDK.STTransaction<Item>, rhs: StayTunedSDK.STTransaction<Item>) -> Swift.Bool
}
extension STTransaction where Item == StayTunedSDK.STContentLight {
  public init(content: StayTunedSDK.STContentLight, paymentType: Swift.String)
}
extension STTransaction where Item == StayTunedSDK.STTrack {
  public init(track: StayTunedSDK.STTrack, paymentType: Swift.String)
}
public typealias STContentTransaction = StayTunedSDK.STTransaction<StayTunedSDK.STContentLight>
public typealias STTrackTransaction = StayTunedSDK.STTransaction<StayTunedSDK.STTrack>
@_hasMissingDesignatedInitializers final public class STAds : StayTunedSDK.STFeature {
  public static func getInstance() throws -> StayTunedSDK.STAds
  @objc deinit
}
extension STAds {
  final public var configuration: StayTunedSDK.STAdsConfiguration {
    get
  }
  final public func setConfiguration(_ configuration: StayTunedSDK.STAdsConfiguration)
}
extension STAds : StayTunedSDK.STObservableProtocol {
  final public func add(observer: StayTunedSDK.STAdsObserver)
  final public func remove(observer: StayTunedSDK.STAdsObserver)
  public typealias Observer = StayTunedSDK.STAdsObserver
}
public protocol STAdsObserver : AnyObject {
  func stAdsDidStart()
  func stAdsDidPaused()
  func stAdsDidFinished()
  func stAdsDidFailed()
}
public enum STSectionType : Swift.String, Swift.Codable {
  case `default`
  case new
  case trailer
  case highlight
  case category
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public struct STSection {
  public let id: Swift.Int
  public let name: Swift.String
  public let type: StayTunedSDK.STSectionType
  public let linkedContentType: StayTunedSDK.STSectionLinkedContentType?
  public let contentType: StayTunedSDK.STContentTypeEnum?
  public let order: Swift.Int?
  public let highlighted: Swift.Bool?
  public let searchable: Swift.Bool?
  public let grouped: Swift.Bool?
  public let numberOfItems: Swift.Int?
  public let itemsLimit: Swift.Int?
  public let itemsLimitOffset: Swift.Int?
  public let imgSrc: Swift.String?
  public let landscapeImgSrc: Swift.String?
  public let hdImgSrc: Swift.String?
  public let hdLandscapeImgSrc: Swift.String?
  public let mainColor: Swift.String?
  public let tags: [Swift.String]?
  public let linkedContents: [StayTunedSDK.STContentLight]?
  public let linkedElements: [StayTunedSDK.STTrack]?
  public let createdAt: Foundation.Date?
  public let updatedAt: Foundation.Date?
  public init(id: Swift.Int, name: Swift.String, type: StayTunedSDK.STSectionType, linkedContentType: StayTunedSDK.STSectionLinkedContentType?, contentType: StayTunedSDK.STContentTypeEnum?, order: Swift.Int?, highlighted: Swift.Bool?, searchable: Swift.Bool?, grouped: Swift.Bool?, numberOfItems: Swift.Int?, itemsLimit: Swift.Int?, itemsLimitOffset: Swift.Int?, imgSrc: Swift.String?, landscapeImgSrc: Swift.String?, hdImgSrc: Swift.String?, hdLandscapeImgSrc: Swift.String?, mainColor: Swift.String?, tags: [Swift.String]?, linkedContents: [StayTunedSDK.STContentLight]?, linkedElements: [StayTunedSDK.STTrack]?, createdAt: Foundation.Date?, updatedAt: Foundation.Date?)
}
extension STSection : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: StayTunedSDK.STSection, b: StayTunedSDK.STSection) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct STTrackViewConfiguration : StayTunedSDK.STUIInstantiableConfiguration {
  public let track: StayTunedSDK.STTrack
  public init(track: StayTunedSDK.STTrack)
}
public protocol STUIInjectionTrackView : UIKit.UIViewController {
  init(_ configuration: StayTunedSDK.STTrackViewConfiguration)
}
public enum STSectionLinkedContentType : Swift.String, Swift.Codable {
  case content
  case element
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public struct STExpandConfiguration {
  public var onContextButtonClick: ((UIKit.UIViewController) -> Swift.Void)?
  public init(onContextButtonClick: ((UIKit.UIViewController) -> Swift.Void)? = nil)
}
public protocol STUIInstantiableConfiguration {
}
@_hasMissingDesignatedInitializers final public class STUIInjection : StayTunedSDK.STFeature {
  public static func getInstance() throws -> StayTunedSDK.STUIInjection
  final public func inject(contentView: StayTunedSDK.STUIInjectionContentView.Type)
  final public func inject(trackView: StayTunedSDK.STUIInjectionTrackView.Type)
  final public func inject(playerView: StayTunedSDK.STUIInjectionPlayerView.Type)
  final public func instantiate(_ config: StayTunedSDK.STUIInstantiableConfiguration) -> UIKit.UIViewController?
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class STAuth : StayTunedSDK.STFeature {
  public enum Status {
    case authenticating
    case notAuthenticated
    case authenticated
    public static func == (a: StayTunedSDK.STAuth.Status, b: StayTunedSDK.STAuth.Status) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  final public var retryHandler: ((((Swift.Result<Swift.Void, Swift.Error>) -> Swift.Void)?) -> Swift.Void)? {
    get
    set
  }
  final public var status: StayTunedSDK.STAuth.Status {
    get
  }
  public static func getInstance() throws -> StayTunedSDK.STAuth
  final public func getHeaders() -> [Swift.String : Swift.String]
  @objc deinit
}
extension STAuth {
  final public func connect(partnerKey: Swift.String, partnerToken: Swift.String, completion: ((Swift.Result<Swift.Void, Swift.Error>) -> Swift.Void)?)
  final public func connectAnonymous(completion: ((Swift.Result<Swift.Void, Swift.Error>) -> Swift.Void)?)
  final public func disconnect()
}
extension STAuth : StayTunedSDK.STObservableProtocol {
  final public func add(observer: StayTunedSDK.STAuthObserver)
  final public func remove(observer: StayTunedSDK.STAuthObserver)
  public typealias Observer = StayTunedSDK.STAuthObserver
}
public protocol STAuthObserver : AnyObject {
  @available(*, deprecated, message: "The method will be removed. Please use authStatusDidChange.")
  func didConnect()
  func authStatusDidChange(to status: StayTunedSDK.STAuth.Status)
}
@objc open class STEpisodeSceneViewConttroller : UIKit.UITableViewController, StayTunedSDK.STUIInjectionTrackView {
  required public init(_ configuration: StayTunedSDK.STTrackViewConfiguration)
  @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc override dynamic open func viewWillAppear(_ animated: Swift.Bool)
  @objc override dynamic open func viewDidAppear(_ animated: Swift.Bool)
  @objc override dynamic open func numberOfSections(in tableView: UIKit.UITableView) -> Swift.Int
  @objc override dynamic open func tableView(_ tableView: UIKit.UITableView, numberOfRowsInSection section: Swift.Int) -> Swift.Int
  @objc override dynamic open func tableView(_ tableView: UIKit.UITableView, cellForRowAt indexPath: Foundation.IndexPath) -> UIKit.UITableViewCell
  @objc override dynamic public init(style: UIKit.UITableView.Style)
  @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @objc deinit
}
public struct STContentLight {
  public let key: Swift.String
  public let type: StayTunedSDK.STContentModelType?
  public let title: Swift.String
  public let ean: Swift.String?
  public let imgSrc: Swift.String?
  public let portraitImgSrc: Swift.String?
  public let landscapeImgSrc: Swift.String?
  public let narrator: Swift.String?
  public let author: Swift.String?
  public let publicationDate: Foundation.Date?
  public let overallDuration: Swift.Int?
  public let createdAt: Foundation.Date?
  public let updatedAt: Foundation.Date?
  public init(key: Swift.String, type: StayTunedSDK.STContentModelType, title: Swift.String, imgSrc: Swift.String)
}
extension STContentLight : Swift.Equatable {
  public static func == (lhs: StayTunedSDK.STContentLight, rhs: StayTunedSDK.STContentLight) -> Swift.Bool
}
extension STContentLight : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct STTrackOfflineItem : Swift.Codable {
  public let audioItem: StayTunedSDK.STTrack
  public var state: StayTunedSDK.STOfflineState
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public protocol STInternalPlayerEventsProtocol : AnyObject {
  func playerWillStart(for track: StayTunedSDK.STTrack)
  func playerDidFinish(for track: StayTunedSDK.STTrack)
  func didFailedToloadItem(for itemUrl: Swift.String, error: Swift.String)
}
public struct STListItem<Item> {
  public var id: Swift.Int?
  public var key: Swift.String?
  public var item: Item?
  public var order: Swift.Int?
  public var value: Swift.String?
  public var createdAt: Foundation.Date?
  public var updatedAt: Foundation.Date?
}
extension STListItem : Swift.Equatable {
  public static func == (lhs: StayTunedSDK.STListItem<Item>, rhs: StayTunedSDK.STListItem<Item>) -> Swift.Bool
}
extension STListItem {
  public static func defaultOrder(lhs: StayTunedSDK.STListItem<Item>, rhs: StayTunedSDK.STListItem<Item>) -> Swift.Bool
}
extension STListItem where Item == StayTunedSDK.STTrack {
  public init(track: StayTunedSDK.STTrack)
}
extension STListItem where Item == StayTunedSDK.STContentLight {
  public init(contentLight: StayTunedSDK.STContentLight)
}
extension StayTunedSDK.STError : Swift.Equatable {}
extension StayTunedSDK.STError : Swift.Hashable {}
extension StayTunedSDK.STAudioQuality : Swift.Equatable {}
extension StayTunedSDK.STAudioQuality : Swift.Hashable {}
extension StayTunedSDK.STContentModelType : Swift.Equatable {}
extension StayTunedSDK.STContentModelType : Swift.Hashable {}
extension StayTunedSDK.STContentModelType : Swift.RawRepresentable {}
extension StayTunedSDK.STContentMediaType : Swift.Equatable {}
extension StayTunedSDK.STContentMediaType : Swift.Hashable {}
extension StayTunedSDK.STContentMediaType : Swift.RawRepresentable {}
extension StayTunedSDK.STContentDiffusionMode : Swift.Equatable {}
extension StayTunedSDK.STContentDiffusionMode : Swift.Hashable {}
extension StayTunedSDK.STContentDiffusionMode : Swift.RawRepresentable {}
extension StayTunedSDK.STContentDisponibilityStatus : Swift.Equatable {}
extension StayTunedSDK.STContentDisponibilityStatus : Swift.Hashable {}
extension StayTunedSDK.STContentDisponibilityStatus : Swift.RawRepresentable {}
extension StayTunedSDK.STUIOptions.UserInterfaceStyle : Swift.Equatable {}
extension StayTunedSDK.STUIOptions.UserInterfaceStyle : Swift.Hashable {}
extension StayTunedSDK.STListLinkedContentType : Swift.Equatable {}
extension StayTunedSDK.STListLinkedContentType : Swift.Hashable {}
extension StayTunedSDK.STListLinkedContentType : Swift.RawRepresentable {}
extension StayTunedSDK.STAPIDownloadError : Swift.Equatable {}
extension StayTunedSDK.STAPIDownloadError : Swift.Hashable {}
extension StayTunedSDK.STFloatingChipConfiguration.Size : Swift.Equatable {}
extension StayTunedSDK.STFloatingChipConfiguration.Size : Swift.Hashable {}
extension StayTunedSDK.STFloatingChipConfiguration.Size : Swift.RawRepresentable {}
extension StayTunedSDK.STContentTypeEnum : Swift.Equatable {}
extension StayTunedSDK.STContentTypeEnum : Swift.Hashable {}
extension StayTunedSDK.STContentTypeEnum : Swift.RawRepresentable {}
extension StayTunedSDK.STOfflineError : Swift.Equatable {}
extension StayTunedSDK.STOfflineError : Swift.Hashable {}
extension StayTunedSDK.STPlayerState : Swift.Equatable {}
extension StayTunedSDK.STPlayerState : Swift.Hashable {}
extension StayTunedSDK.STTrackModelType : Swift.Equatable {}
extension StayTunedSDK.STTrackModelType : Swift.Hashable {}
extension StayTunedSDK.STTrackModelType : Swift.RawRepresentable {}
extension StayTunedSDK.STTrackTypeOfElement : Swift.Equatable {}
extension StayTunedSDK.STTrackTypeOfElement : Swift.Hashable {}
extension StayTunedSDK.STTrackTypeOfElement : Swift.RawRepresentable {}
extension StayTunedSDK.STSectionType : Swift.Equatable {}
extension StayTunedSDK.STSectionType : Swift.Hashable {}
extension StayTunedSDK.STSectionType : Swift.RawRepresentable {}
extension StayTunedSDK.STSectionLinkedContentType : Swift.Equatable {}
extension StayTunedSDK.STSectionLinkedContentType : Swift.Hashable {}
extension StayTunedSDK.STSectionLinkedContentType : Swift.RawRepresentable {}
extension StayTunedSDK.STAuth.Status : Swift.Equatable {}
extension StayTunedSDK.STAuth.Status : Swift.Hashable {}
